import time
import RPi.GPIO as GPIO
import numpy as np
from gnuradio import gr, blocks, analog, audio
import gnuradio.lora_sdr as lora_sdr
import pmt
#from ocean import plot_spectrogram
import random
import alsaaudio

def find_hifiberry_device():
    devices = alsaaudio.cards()
    for i, device in enumerate(devices):
        if "hifiberry" in device.lower():
            return f"hw:{i},0"
    return None

def play_audio_on_hifiberry(audio_data, samp_rate):
    dev_str = find_hifiberry_device()
    if dev_str is None:
        print("HiFiBerry device not found!")
        return

    audio_data = (audio_data * 10000).astype(np.int16)
    audio_data = audio_data[:len(audio_data) - (len(audio_data) % 1024)]

    output_device = alsaaudio.PCM(
        alsaaudio.PCM_PLAYBACK,
        alsaaudio.PCM_NORMAL,
        device=dev_str,
    )
    output_device.setchannels(1)
    output_device.setrate(samp_rate)
    output_device.setformat(alsaaudio.PCM_FORMAT_S16_LE)
    output_device.setperiodsize(1024)

    try:
        print("Playing audio...")
        for i in range(0, len(audio_data), 1024):
            chunk = audio_data[i:i + 1024].tobytes()
            output_device.write(chunk)
        print("Playback finished.")
    finally:
        output_device.close()
        print("Audio device closed.")




class LoRaTXWrapper(gr.top_block):
    def __init__(self, samp_rate=48000, bw=8000, sf=7, cr=1, has_crc=True, sync_word=[0x12], ldro_mode=2):
        super().__init__()

        self.samp_rate = samp_rate

        # Message input block (we'll set the message dynamically)
        self.message_source = blocks.message_strobe(pmt.intern(""), 1000)

        # LoRa TX block
        self.lora_tx = lora_sdr.lora_sdr_lora_tx(
            bw=bw,
            cr=cr,
            has_crc=has_crc,
            impl_head=False,
            samp_rate=samp_rate,
            sf=sf,
            ldro_mode=ldro_mode,
            frame_zero_padd=1280
            # sync_word=sync_word
        )

        # Sink for capturing output as array
        self.vector_sink = blocks.vector_sink_c()

        # Connect
        self.msg_connect(self.message_source, 'strobe', self.lora_tx, 'in')
        self.connect(self.lora_tx, self.vector_sink)

    def transmit_message(self, msg_str, delay = 1.2):
        """
        Take a message and output a string of samples.
        Args:
            msg_str (str): Message to be transmitted.
            delay (float): Delay in seconds before stopping the flowgraph. I deally, just leave \
                (1 + a bit) for the strobe to produce a single message.
        Returns:
            np.array: Array of complex samples generated by the LoRa TX block, upchirping at baseband.
        """

        # Replace the strobe message dynamically
        #self.message_source.set_msg(pmt.intern(msg_str))

        #self.message_source.set_msg(
        #    pmt.cons(
        #        pmt.PMT_NIL,
        #        pmt.init_u8vector(len(msg_str), msg_str)
        #    )
        #)

        self.message_source.set_msg(pmt.intern(bytes(msg_str).hex()))


        #hex_str = ''.join('{:02x}'.format(b) for b in msg_str)
        #self.message_source.set_msg(pmt.cons(pmt.PMT_NIL, pmt.intern(hex_str)))



        # Start flowgraph
        self.start()
        time.sleep(delay)  # Wait for the message to be processed
        self.stop()
        self.wait()
        

        # Retrieve and return samples
        samples = np.array(self.vector_sink.data(), dtype=np.complex64)
        self.vector_sink.reset()
        return samples



if __name__ == "__main__":
    random.seed(42)  # For reproducibility

    SAMP_RATE = 48000 # Typically 120000 for Acoustic LoRa
    CENTER_FREQ = 12500  # Center frequency in Hz

    tx = LoRaTXWrapper(samp_rate=SAMP_RATE, bw=8000, sf=7)
    
    #Generate a byte array of random samples ranging from 0 to 128
    random_bytes = bytearray(random.getrandbits(7) for _ in range(50))
    random_bytes[4] = 0x00

    print("Random bytes: ", [f"{byte:02x}" for byte in random_bytes])

    samples = tx.transmit_message(random_bytes)
    print("Generated", len(samples), "samples")

    # TODO: Right now, you have been handed a complex array of samples. You need to:
    # 1. Change it to the complex conjugate (for down chirps)
    # 2. Modulate it to the center frequency
    # 3. Convert to real for audio playback

    # Currently centered on 0 Hz, center it to 12.5 kHz
    t = np.arange(len(samples)) / float(SAMP_RATE)  # Time array based on sample rate
    samples_new = samples * np.exp(2j * np.pi * CENTER_FREQ * t)  # Apply frequency shift



    #plot_spectrogram(samples_new, samp_rate=48000)

    # Play the audio on HiFiBerry
    find_hifiberry_device()

    GPIO.setmode(GPIO.BCM) # Pins will be refered to based on the BCM GPIO numbering
    GPIO.setwarnings(False) 
    GPIO.setup(26, GPIO.OUT)

    # Turn on the MOSFET switch, activating the relay
    GPIO.output(26, GPIO.HIGH)

    time.sleep(1)

    play_audio_on_hifiberry(samples_new, SAMP_RATE)

    GPIO.cleanup()
    print("Audio device closed, GPIO cleaned up.")
